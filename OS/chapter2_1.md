## 2.1 进程与线程

### 2.1.1 进程的概念和特征

1.   **进程的概念**

     为了允许多个程序并发执行，引入进程概念，进程可以更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。

     进程控制块PCB是用来描述进程的基本情况和运行状态，进而控制和管理进程。

     程序段、相关数据段和PCB三部分构成了进程实体(进程映像)。创建进程就是创建进程实体中的PCB；撤销进程就是撤销进程的PCB。

     

2.   **进程的特征**

     进程和程序是两个不同的概念，进程的基本特征有以下几个：

     -   动态性。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。
     -   并发性。指多个进程实体同存于内存中，能在一段时间内同时允许。引入进程的目的就是使进程能和其他进程并发执行。并发性是进程的重要特征，也是操作系统的重要特征。
     -   独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。
     -   异步性。由于进程的相互制约，使得进程按各自独立的、不可预知的速度向前推进。



### 2.1.2 进程的状态与转换

-   运行态。进程正在处理机上运行。
-   就绪态。进程获得除了处理机外的一切所需资源，一旦得到处理机，便可立即运行。
-   阻塞态。进程正在等待某一事件而暂停运行，如等待某资源为可用或等待输入/输出完成。即使处理机空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。
-   创建态。进程正在被创建，尚未转到就绪态。创建进程需要多个步骤：首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后把该进程转入就绪态并插入就绪队列。
-   终止态。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程置为终止态，然后进一步处理资源释放和回收等工作。



-   就绪态-->运行态：处于就绪态的进程被调度后，获得处理机资源，于是进程由就绪态转换为运行态。
-   运行态-->就绪态：处于运行态的进程在时间片用完后，不得不让出处理机，从而进程由运行态转换为就绪态。
-   运行态-->阻塞态：进程请求某一资源的使用和分配或等待某一事件的发生时，它就从运行态转换为阻塞态。
-   阻塞态-->就绪态：进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。

<img src='./pics/进程五态图.jpeg' width='70%' align='center'>



### 2.1.3 进程的组成

进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。

1.   进程控制块

     进程创建时，操作系统为它新建一个PCB，然后常驻内存，在进程结束时删除。PCB是进程实体的一部分，是进程存在的唯一标志。

     下表为PCB的一个实例

     | 进程描述信息    | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
     | --------------- | ------------------ | ------------ | -------------- |
     | 进程标识符(PID) | 进程当前状态       | 代码段指针   | 通用寄存器值   |
     | 用户标识符(UID) | 进程优先级         | 数据段指针   | 地址寄存器值   |
     |                 | 代码运行入口地址   | 堆栈段指针   | 控制寄存器值   |
     |                 | 程序的外存地址     | 文件描述符   | 标志寄存器值   |
     |                 | 进入内存时间       | 键盘         | 状态字         |
     |                 | 处理机占用时间     | 鼠标         |                |
     |                 | 信号量使用         |              |                |

     1）进程描述信息。进程标识符：标志各个进程，每个进程都有一个唯一的标识号。用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。

     2）进程控制和管理系你行。进程当前状态：描述进程的状态信息，作为处理机分配调度的依据。进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。

     3）资源分配清单，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。

     4）处理机相关信息，也称为处理机的上下文，主要指处理机中各寄存器的值。当进程处于执行态时，处理机的许多信息都在寄存器中。当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。

     

2.   程序段

     程序段就是能被进程调度程序调度到CPU执行的程序代码段；

3.   数据段

     一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。



### 2.1.4 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序称为原语，原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。

1.   **进程的创建**

     允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。

     在操作系统中，终端用户登陆系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。接下来是创建原语:

     1）为进程分配一个唯一的进程标识号，并申请一个空白的PCB。若PCB申请失败，则创建失败。

     2）为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等。这些资源或从操作系统获得，或仅从父进程获得。如果资源不足，则并不是创建失败，而是处于创建态，等待内存资源。

     3）初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。

     4）若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。

2.   **进程的终止**

     引起进程终止的事件主要有：正常结束，表示进程的任务已完成并准备退出运行。异常结束，表示进程在运行时，发生了某种事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、I/O故障等。外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。

     操作系统终止进程的过程如下：

     1）根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态

     2）若被终止进程处于运行状态，立即终止该进程的执行，将处理机资源分配给其他进程

     3）若该进程还有子孙进程，则应将其所有子孙进程终止

     4）将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统

     5）将该PCB从所在队列(链表)中删除

3.   进程的阻塞和唤醒

     进程如果出现请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等，进程可以通过调用阻塞原语，从运行态变为阻塞态。阻塞原语的执行过程如下：

     1）在该事件的等待队列中找到相应进程的PCB

     2）若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行

     3）把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程

     当被阻塞进程所期待的事件出现时，如它所期待的I/O操作已完成或其所期待的数据已到达，由有关进程调用唤醒原语，将等待该事件的进程唤醒。唤醒原语的执行过程如下：

     1）在该事件的等待队列中找到相应进程的PCB

     2）将其从等待队列中移出，并置其状态为就绪态

     3）把该PCB插入就绪队列，等待调度程序调度

     Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用。



### 2.1.5 进程的通信

进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是以较高的效率传输大量数据的通信方式。

高级通信方式有三种：

1.   共享存储

     在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读/写操作实现进程之间的信息交换。在对共享空间进行读/写操作时，需要使用同步互斥工具（P操作、V操作），对共享空间的写和读进行控制。共享存储分为：低级方式的共享是基于数据结构的共享；高级方式的共享则是基于存储区的共享。OS只负责提供存储空间和同步互斥工具，数据交换由用户自己编写。

2.   消息传递

     在消息传递系统中，进程间的数据交换以格式化的消息（Message）为单位。

     -   直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息
     -   间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体称为信箱。

3.   管道通信

     管道通信允许两个进程按生产者-消费者进行通信，生产者向管道的一端写，消费者从管道的另一端读。数据在管道中先进先出。管道机制必须提供三方面的协调能力：互斥、同步和确定对方的存在。管道可以克服使用文件进行通信的两个问题：

     1）限制管道的大小。

     2）读进程也可能工作得比写进程快。

     

### 2.1.6 线程和多线程模型

1.   **线程的基本概念**

     引入**进程**的目的是更好地使多道程序**并发执行**，**提高资源利用率和系统吞吐量**；而引入**线程**的目的是减小程序在并发时所付出的**时空开销**，**提高操作系统的并发性能**

     线程就是“轻量级进程”，是一个基本的CPU执行单元，是程序执行流的最小单元，由**线程ID**、**程序计数器**、**寄存器集合**和**堆栈**组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程不会拥有系统资源，线程可以和其他同进程中的线程共享进程的所有资源。线程有就绪、阻塞和运行三种状态。

     引入线程后，进程只作为除CPU外的系统资源的分配单位，而线程则作为处理机的分配单位。

2.   **线程与进程的比较**

     1）**调度**。在引入线程的操作系统中，线程是独立调度的基本单位，而线程切换的代价远低于进程。在同一进程中，线程的切换不会引起进程的切换。

     2）**并发性**。引入线程的操作系统，不仅可以进程并发执行，还可以线程并发执行。

     3）**拥有资源**。进程拥有系统资源，但线程没有，线程可以访问隶属进程的系统资源，主要表现在同属于同一进程的所有线程都具有相同的地址空间。

     4）**独立性**。

     5）**系统开销**。进程切换时涉及到进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。

     6）**支持多处理机系统**。对于单线程进程，进程只能运行在一个处理机上。对于多线程进程，可以将进程中的多个线程分配到多个处理机上。

3.   **线程的属性**

     1）线程是一个轻型实体，线程有唯一标识符和一个线程控制块，记录了线程执行的寄存器和栈等现场状态

     2）不同线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的进程

     3）同一进程中的各个线程共享该进程所拥有的资源

     4）线程是处理机的独立调度单元，多个线程是可以并发执行的，

     5）线程被创建后，就开始了生命周期。在生命周期内会经历阻塞态、就绪态和运行态等各种变化。

4.   **线程的状态与转换**

     -   **执行态**：线程已获得处理机而正在运行
     -   **就绪态**：线程已具备各种执行条件，只需再获得CPU便可立即执行
     -   **阻塞态**：线程在执行中因某事件受阻而处于暂停状态

5.   **线程的组织与控制**

     -   线程控制块

         线程控制块包括**线程标识符**、**一组寄存器**（程序计数器、状态寄存器和通用寄存器）、**线程运行状态**、**优先级**、**线程专有存储区**，线程切换时用于保护现场等、**堆栈指针**，用于过程调用时保存局部变量及返回地址等。

         同一进程的所有线程都完全共享进程的地址空间和全部变量。

     -   线程的创建

         用户程序启动时，会有一个称为“初始化线程”的线程正在执行，主要功能是用于创建新线程。创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程住程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完之后，将返回一个线程标识符。

     -   线程的终止

         线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。

6.   **线程的实现方式**

     线程的实现可以分为两类：用户级线程(User-Level Thread, ULT)和内核级线程(Kernel-Level Thread, KLT)。

     -   用户级线程(ULT)

         用户级线程有关线程管理的所有工作都由应用程序在用户空间中完成，内核意识不到线程的存在。

         对于设置了用户级线程的系统，其调度仍是以进程为单位进行的，各个进程轮流执行一个时间片。

         优点：线程切换不需要转换到内核空间，节省了模式切换的开销。调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。

         缺点：系统调用阻塞问题、无法发挥多处理机的优势

     -   内核级线程(KLT)

         在操作系统内核的支持下运行，线程管理也是在内核空间实现。

         优点：能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可以运行其他进程中的线程。内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。内核本身也可以采用多线程技术，提高系统的执行速度和效率。

         缺点：同一进程中的线程切换，需要从用户态转到核心态，系统开销比较大。

     -   组合方式

         支持多个内核级线程的建立、调度和管理，同时允许用户建立、调度和管理用户级线程。

         线程库（Thread Library)：在用户空间中提供一个没有内核支持的库，代码和数据结构都位于用户空间中。实现由操作系统直接支持的内核级的一个库。

         主流线程库有：POSIX Pthreads, Windows API, Java

7.   多线程模型

     1）多对一模型。

     ​	优点：线程管理是在用户空间进行的，效率比较高

     ​	缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。

     2）

     

     